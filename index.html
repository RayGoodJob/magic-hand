<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI éš”ç©ºæ‰‹å†™æ¿ (MediaPipe)</title>
    <style>
        body { margin: 0; padding: 0; background: #111; overflow: hidden; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        /* è§†é¢‘å±‚ï¼šé•œåƒç¿»è½¬ï¼Œçœ‹èµ·æ¥åƒç…§é•œå­ */
        #webcam { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); display: block; }
        /* ç”»å¸ƒå±‚ï¼šè¦†ç›–åœ¨è§†é¢‘ä¹‹ä¸Š */
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        /* åŠ è½½æç¤º */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; z-index: 100; pointer-events: none; }
        /* è°ƒè¯•/çŠ¶æ€ä¿¡æ¯ */
        #status { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 16px; background: rgba(0,0,0,0.5); padding: 5px; z-index: 50; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="container">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="loading">æ­£åœ¨åŠ è½½ AI æ¨¡å‹ï¼Œè¯·ç¨å€™...</div>
    <div id="status">çŠ¶æ€: åˆå§‹åŒ–ä¸­...</div>
</div>

<script type="module">
import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const video = document.getElementById('webcam');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d');
const loadingDiv = document.getElementById('loading');
const statusDiv = document.getElementById('status');

let handLandmarker = undefined;
let lastVideoTime = -1;
let results = undefined;

// --- çŠ¶æ€å˜é‡ ---
let strokes = []; // å­˜å‚¨æ‰€æœ‰ç¬”ç”»: [{points: [{x,y}], color, size, isEraser}]
let currentStroke = null;
let particles = []; // é›ªèŠ±ç²’å­

// ç”»ç¬”è®¾ç½®
let toolState = {
    color: '#00FF00', // é»˜è®¤ç»¿è‰²
    size: 5,
    mode: 'pen', // 'pen' or 'eraser'
    menuOpen: false
};

// æ‰‹åŠ¿äº¤äº’å˜é‡
let isPinching = false;
let pinchStartPoint = null;
let lastPinchCenter = null;

// ç¼©æ”¾ç›¸å…³
let isZooming = false;
let baseZoomDist = 0;
let canvasScale = 1;
let canvasOffset = { x: 0, y: 0 };
let lastCanvasScale = 1;

// èœå•é˜²æŠ–
let menuToggleCooldown = 0;

// UI å¸ƒå±€å®šä¹‰
const UI_BUTTONS = [
    { id: 'pen', label: 'âœï¸ ç¬”', type: 'tool', value: 'pen', x: 50, y: 100, w: 80, h: 60, color: '#fff' },
    { id: 'eraser', label: 'ğŸ§¹ æ“¦', type: 'tool', value: 'eraser', x: 50, y: 170, w: 80, h: 60, color: '#fff' },
    { id: 'red', label: 'ğŸ”´', type: 'color', value: '#FF0000', x: 140, y: 100, w: 60, h: 60, color: '#FF0000' },
    { id: 'green', label: 'ğŸŸ¢', type: 'color', value: '#00FF00', x: 140, y: 170, w: 60, h: 60, color: '#00FF00' },
    { id: 'blue', label: 'ğŸ”µ', type: 'color', value: '#0000FF', x: 210, y: 100, w: 60, h: 60, color: '#0000FF' },
    { id: 'size_s', label: 'å°', type: 'size', value: 3, x: 210, y: 170, w: 60, h: 60, color: '#aaa' },
    { id: 'size_l', label: 'å¤§', type: 'size', value: 10, x: 280, y: 170, w: 60, h: 60, color: '#aaa' },
];

let hoverTimer = 0;
let lastHoverId = null;

// --- 1. åˆå§‹åŒ– MediaPipe ---
async function createHandLandmarker() {
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 2
    });
    loadingDiv.style.display = 'none';
    startCamera();
}

// --- 2. å¼€å¯æ‘„åƒå¤´ ---
function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then((stream) => {
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictWebcam);
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    });
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

// --- æ ¸å¿ƒå¾ªç¯ ---
async function predictWebcam() {
    // è®¾ç½® Canvas å°ºå¯¸åŒ¹é…è§†é¢‘æµæ¯”ä¾‹ (ä¿æŒå…¨å±è¦†ç›–)
    if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        results = handLandmarker.detectForVideo(video, performance.now());
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // é€»è¾‘å¤„ç†
    handleGestures();
    
    // æ¸²æŸ“å¤„ç†
    drawStrokes();
    drawParticles(); // é›ªèŠ±ç‰¹æ•ˆ
    drawUI();        // å¦‚æœèœå•æ‰“å¼€
    drawCursor();    // ç»˜åˆ¶æ‰‹åŠ¿åé¦ˆç‚¹

    requestAnimationFrame(predictWebcam);
}

// --- 3. æ‰‹åŠ¿é€»è¾‘å¤„ç† ---
function handleGestures() {
    if (!results || !results.landmarks || results.landmarks.length === 0) {
        statusDiv.innerText = "çŠ¶æ€: æœªæ£€æµ‹åˆ°æ‰‹";
        return;
    }

    const hands = results.landmarks;
    const handedness = results.handedness; // Left/Right check

    // å†·å´æ—¶é—´é€’å‡
    if (menuToggleCooldown > 0) menuToggleCooldown--;

    // æ£€æµ‹å•æ‰‹æ“ä½œ
    if (hands.length === 1) {
        const lm = hands[0];
        
        // 1. æ£€æµ‹æ˜¯å¦å¼ å¼€æ‰‹æŒ (Open Palm) -> Toggle Menu
        if (detectOpenPalm(lm) && menuToggleCooldown === 0) {
            toolState.menuOpen = !toolState.menuOpen;
            menuToggleCooldown = 60; // 1ç§’å†·å´
            statusDiv.innerText = toolState.menuOpen ? "çŠ¶æ€: èœå•å¼€å¯" : "çŠ¶æ€: èœå•å…³é—­";
        }

        // 2. èœå•æ¨¡å¼ä¸‹çš„äº¤äº’ (Menu Mode Interaction)
        if (toolState.menuOpen) {
            handleMenuInteraction(lm);
            return; // èœå•å¼€å¯æ—¶ï¼Œä¸è¿›è¡Œä¹¦å†™
        }

        // 3. æ£€æµ‹æ¸…é™¤æ‰‹åŠ¿ (Victory/Peace Sign) -> Clear & Snow
        if (detectVictorySign(lm)) {
            triggerSnowEffect();
            statusDiv.innerText = "çŠ¶æ€: æ¸…é™¤ç”»å¸ƒ";
            return;
        }

        // 4. æ£€æµ‹ä¹¦å†™æ‰‹åŠ¿ (Pinch) -> Write
        const pinchDist = distance(lm[4], lm[8]); // æ‹‡æŒ‡ä¸é£ŸæŒ‡
        if (pinchDist < 0.05) { // é˜ˆå€¼ï¼Œæ ¹æ®æ‘„åƒå¤´è·ç¦»å¯èƒ½éœ€è¦å¾®è°ƒ
            isPinching = true;
            statusDiv.innerText = toolState.mode === 'eraser' ? "çŠ¶æ€: æ©¡çš®æ“¦" : "çŠ¶æ€: ä¹¦å†™ä¸­";
            
            // åæ ‡è½¬æ¢ (å½’ä¸€åŒ– -> å±å¹•åæ ‡)
            const x = lm[8].x * canvas.width;
            const y = lm[8].y * canvas.height;

            // åå‘åº”ç”¨ç¼©æ”¾ï¼Œä»¥ä¾¿å°†ç¬”ç”»è®°å½•åœ¨â€œä¸–ç•Œåæ ‡â€ä¸­
            const worldX = (x - canvasOffset.x) / canvasScale;
            const worldY = (y - canvasOffset.y) / canvasScale;

            if (!currentStroke) {
                currentStroke = {
                    points: [{x: worldX, y: worldY}],
                    color: toolState.color,
                    size: toolState.size,
                    isEraser: toolState.mode === 'eraser'
                };
                strokes.push(currentStroke);
            } else {
                currentStroke.points.push({x: worldX, y: worldY});
            }
        } else {
            isPinching = false;
            currentStroke = null;
            if (!toolState.menuOpen) statusDiv.innerText = "çŠ¶æ€: å‡†å¤‡ä¹¦å†™";
        }
    } 
    // åŒæ‰‹æ“ä½œ
    else if (hands.length === 2) {
        // 5. æ£€æµ‹åŒæ‰‹ç¼©æ”¾ (Zoom)
        // å‡è®¾å·¦å³æ‰‹éƒ½æ˜¯é£ŸæŒ‡ä¼¸å‡º
        const h1 = hands[0];
        const h2 = hands[1];
        
        // ç®€å•åˆ¤æ–­ï¼šåªè¦ä¸æ˜¯æåˆçŠ¶æ€ï¼Œä¸”ä¸¤ä¸ªé£ŸæŒ‡éƒ½ä¼¸å‡º
        if (!detectPinch(h1) && !detectPinch(h2)) {
            const idx1 = { x: h1[8].x * canvas.width, y: h1[8].y * canvas.height };
            const idx2 = { x: h2[8].x * canvas.width, y: h2[8].y * canvas.height };
            
            const dist = Math.hypot(idx1.x - idx2.x, idx1.y - idx2.y);
            const cx = (idx1.x + idx2.x) / 2;
            const cy = (idx1.y + idx2.y) / 2;

            if (!isZooming) {
                isZooming = true;
                baseZoomDist = dist;
                lastCanvasScale = canvasScale; // è®°å½•å¼€å§‹æ—¶çš„ç¼©æ”¾
                statusDiv.innerText = "çŠ¶æ€: ç¼©æ”¾ä¸­...";
            } else {
                // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
                const ratio = dist / baseZoomDist;
                const newScale = lastCanvasScale * ratio;
                
                // é™åˆ¶ç¼©æ”¾èŒƒå›´
                if (newScale > 0.5 && newScale < 5.0) {
                    // ç®€å•çš„ç¼©æ”¾é€»è¾‘ï¼šä»¥å±å¹•ä¸­å¿ƒä¸ºåŸºå‡†ï¼ˆæ›´å¤æ‚çš„éœ€è¦ä»¥åŒæ‰‹ä¸­å¿ƒä¸ºåŸºå‡†ï¼‰
                    // ä¸ºäº†ç®€åŒ–ä»£ç ï¼Œè¿™é‡Œå®ç°ä»¥å±å¹•ä¸­å¿ƒç¼©æ”¾
                    canvasScale = newScale;
                    
                    // å¦‚æœæƒ³è¦ä»¥åŒæ‰‹ä¸­å¿ƒç¼©æ”¾ï¼Œéœ€è¦å¤æ‚çš„çŸ©é˜µåç§»è®¡ç®—ï¼Œæ­¤å¤„ç®€åŒ–å¤„ç†
                }
            }
        } else {
            isZooming = false;
        }
    }
}

// --- è¾…åŠ©æ£€æµ‹å‡½æ•° ---

function distance(p1, p2) {
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
}

// æ£€æµ‹æåˆ (è¾…åŠ©ç”¨)
function detectPinch(lm) {
    return distance(lm[4], lm[8]) < 0.05;
}

// æ£€æµ‹å¼ å¼€æ‰‹æŒ: æ‰€æœ‰æ‰‹æŒ‡æŒ‡å°–è·ç¦»æŒå¿ƒ(0)æ¯”å…³èŠ‚è·ç¦»æŒå¿ƒè¿œï¼Œä¸”æ‰‹æŒ‡æ˜¯åˆ†å¼€çš„
function detectOpenPalm(lm) {
    // ç®€å•åˆ¤æ–­ï¼šæŒ‡å°–(8,12,16,20) yåæ ‡å°äºå…³èŠ‚(6,10,14,18) yåæ ‡ (æ³¨æ„åæ ‡ç³»yå‘ä¸‹)
    // ä½†æ‰‹å¯èƒ½æ—‹è½¬ã€‚æ›´å¥½çš„æ–¹æ³•æ˜¯åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ã€‚
    // è¿™é‡Œä½¿ç”¨ï¼šé£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡ éƒ½æ˜¯ä¼¸ç›´çŠ¶æ€
    const isExtended = (tip, pip) => distance(lm[tip], lm[0]) > distance(lm[pip], lm[0]) * 1.2;
    
    return isExtended(8, 6) && isExtended(12, 10) && isExtended(16, 14) && isExtended(20, 18) && distance(lm[4], lm[8]) > 0.1;
}

// æ£€æµ‹ Victory/Peace (å‰ªåˆ€æ‰‹): é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
function detectVictorySign(lm) {
    const isExtended = (tip, pip) => distance(lm[tip], lm[0]) > distance(lm[pip], lm[0]);
    const isCurled = (tip, pip) => distance(lm[tip], lm[0]) < distance(lm[pip], lm[0]);
    
    // é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
    return isExtended(8, 6) && isExtended(12, 10) && isCurled(16, 14) && isCurled(20, 18);
}

// --- èœå•äº¤äº’ ---
function handleMenuInteraction(lm) {
    const indexTip = { x: lm[8].x * canvas.width, y: lm[8].y * canvas.height };
    
    let hovered = false;

    // ç»˜åˆ¶æŒ‡å°–å…‰æ ‡
    ctx.beginPath();
    ctx.arc(indexTip.x, indexTip.y, 10, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.fill();

    for (let btn of UI_BUTTONS) {
        // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
        if (indexTip.x > btn.x && indexTip.x < btn.x + btn.w &&
            indexTip.y > btn.y && indexTip.y < btn.y + btn.h) {
            
            hovered = true;
            // ç»˜åˆ¶è¿›åº¦ç¯
            ctx.beginPath();
            ctx.arc(indexTip.x, indexTip.y, 15, 0, (hoverTimer / 30) * Math.PI * 2);
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 3;
            ctx.stroke();

            if (lastHoverId !== btn.id) {
                lastHoverId = btn.id;
                hoverTimer = 0;
            } else {
                hoverTimer++;
                if (hoverTimer > 30) { // åœç•™çº¦ 0.5-1ç§’ è§¦å‘
                    triggerButton(btn);
                    hoverTimer = 0;
                    toolState.menuOpen = false; // é€‰æ‹©åè‡ªåŠ¨å…³é—­èœå•ï¼Œæ ¹æ®éœ€æ±‚
                    menuToggleCooldown = 30;
                }
            }
        }
    }

    if (!hovered) {
        hoverTimer = 0;
        lastHoverId = null;
    }
}

function triggerButton(btn) {
    if (btn.type === 'color') {
        toolState.color = btn.value;
        toolState.mode = 'pen';
    } else if (btn.type === 'tool') {
        toolState.mode = btn.value;
    } else if (btn.type === 'size') {
        toolState.size = btn.value;
    }
    console.log("Selected:", btn.id);
}

// --- æ¸²æŸ“å‡½æ•° ---

function drawUI() {
    if (!toolState.menuOpen) return;

    ctx.save();
    // æ¢å¤åˆ°å±å¹•åæ ‡ç³»ç»˜åˆ¶UI (ä¸å—ç¼©æ”¾å½±å“)
    ctx.setTransform(1, 0, 0, 1, 0, 0); 
    // è¿˜è¦å¤„ç†é•œåƒç¿»è½¬é—®é¢˜ï¼Œå› ä¸ºCSSç¿»è½¬äº†Canvasï¼Œæ–‡å­—ä¼šåã€‚
    // æˆ‘ä»¬çš„CSS transform: scaleX(-1)ã€‚
    // ä¸ºäº†è®©å­—æ­£è¿‡æ¥ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç»˜åˆ¶UIæ—¶å†æ¬¡ç¿»è½¬ï¼Œæˆ–è€…ç›´æ¥ç”»åçš„å­—ã€‚
    // æœ€ç®€å•çš„æ–¹æ¡ˆï¼šåœ¨ç»˜åˆ¶æ–‡å­—æ—¶ scale(-1, 1) å¹¶è°ƒæ•´ä½ç½®ã€‚
    
    // èƒŒæ™¯é®ç½©
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(20, 80, 400, 200);

    UI_BUTTONS.forEach(btn => {
        // æŒ‰é’®èƒŒæ™¯
        ctx.fillStyle = btn.id === lastHoverId ? "#555" : "#333";
        if (
            (btn.type === 'color' && toolState.color === btn.value && toolState.mode === 'pen') ||
            (btn.type === 'tool' && toolState.mode === btn.value) ||
            (btn.type === 'size' && toolState.size === btn.value)
        ) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        }
        
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);

        // å†…å®¹
        if (btn.type === 'color') {
            ctx.fillStyle = btn.value;
            ctx.beginPath();
            ctx.arc(btn.x + btn.w/2, btn.y + btn.h/2, 15, 0, Math.PI*2);
            ctx.fill();
        } else {
            ctx.save();
            // å¤„ç†æ–‡å­—é•œåƒé—®é¢˜ï¼š
            // å½“å‰CSS flipäº†æ•´ä¸ªcanvasã€‚
            // æˆ‘ä»¬éœ€è¦åœ¨ç»˜åˆ¶æ–‡å­—æ—¶ï¼Œå…ˆ translate åˆ°æ–‡å­—ä¸­å¿ƒï¼Œscale(-1, 1)ï¼Œå†ç»˜åˆ¶ã€‚
            ctx.translate(btn.x + btn.w/2, btn.y + btn.h/2);
            ctx.scale(-1, 1); 
            ctx.fillStyle = btn.color;
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(btn.label, 0, 0);
            ctx.restore();
        }
    });

    // æ–‡å­—æç¤º
    ctx.save();
    ctx.translate(220, 50);
    ctx.scale(-1, 1);
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("é£ŸæŒ‡æ‚¬åœé€‰æ‹©", 0, 0);
    ctx.restore();

    ctx.restore();
}

function drawStrokes() {
    ctx.save();
    
    // åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»
    // ç®€å•ä»¥å·¦ä¸Šè§’æˆ–å±å¹•ä¸­å¿ƒä¸ºåŸºç‚¹
    // è¿™é‡Œçš„ translate æ˜¯åŸºäº scale çš„
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(canvasScale, canvasScale);
    ctx.translate(-canvas.width/2, -canvas.height/2);
    
    // ç»˜åˆ¶ç¬”ç”»
    strokes.forEach(stroke => {
        if (stroke.points.length < 2) return;
        
        ctx.beginPath();
        ctx.lineWidth = stroke.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (stroke.isEraser) {
            ctx.globalCompositeOperation = 'destination-out'; // æ“¦é™¤æ¨¡å¼
            ctx.lineWidth = stroke.size * 3; // æ©¡çš®æ“¦å¤§ä¸€ç‚¹
        } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = stroke.color;
        }

        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
            ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        ctx.stroke();
    });

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over'; // æ¢å¤
}

function drawCursor() {
    // ä»…ç”¨äºè°ƒè¯•æˆ–éèœå•æ¨¡å¼ä¸‹çš„æ‰‹æŒ‡ä½ç½®æç¤º
    if (!results || !results.landmarks) return;
    
    ctx.save();
    // ä¸å— global scale å½±å“
    ctx.setTransform(1, 0, 0, 1, 0, 0); 

    for (const landmarks of results.landmarks) {
        // ç»˜åˆ¶é£ŸæŒ‡
        const x = landmarks[8].x * canvas.width;
        const y = landmarks[8].y * canvas.height;
        
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI*2);
        ctx.fillStyle = isPinching ? 'red' : 'cyan';
        ctx.fill();

        // å¦‚æœæåˆï¼Œç»˜åˆ¶æ‹‡æŒ‡è¿æ¥çº¿
        if (isPinching) {
             const tx = landmarks[4].x * canvas.width;
             const ty = landmarks[4].y * canvas.height;
             ctx.beginPath();
             ctx.moveTo(x,y);
             ctx.lineTo(tx,ty);
             ctx.strokeStyle = 'white';
             ctx.stroke();
        }
    }
    ctx.restore();
}

// --- é›ªèŠ±ç²’å­ç‰¹æ•ˆ ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 2; // æ°´å¹³é£˜åŠ¨
        this.vy = Math.random() * 2 + 1;     // ä¸‹è½é€Ÿåº¦
        this.life = 1.0;                     // é€æ˜åº¦
        this.decay = Math.random() * 0.01 + 0.005;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3); // ç»˜åˆ¶åƒç´ ç‚¹
        ctx.globalAlpha = 1.0;
    }
}

function triggerSnowEffect() {
    if (strokes.length === 0) return;

    // å°†æ‰€æœ‰ç¬”ç”»çš„ç‚¹è½¬åŒ–ä¸ºç²’å­
    strokes.forEach(stroke => {
        // é‡‡æ ·ç‚¹ï¼Œä¸è¦æ¯ä¸ªç‚¹éƒ½è½¬åŒ–ï¼Œå¦åˆ™å¤ªå¡
        for (let i = 0; i < stroke.points.length; i += 2) {
            const p = stroke.points[i];
            // è€ƒè™‘å½“å‰çš„ç¼©æ”¾çŠ¶æ€ï¼Œå°†ä¸–ç•Œåæ ‡è½¬å›å±å¹•è§†è§‰åæ ‡äº§ç”Ÿç²’å­
            // ç®€å•èµ·è§ï¼Œç›´æ¥ç”¨ä¸–ç•Œåæ ‡é£˜è½ï¼Œä½†åœ¨è§†è§‰ä¸ŠåŠ ä¸Šç¼©æ”¾
            // ä¸ºäº†æ•ˆæœå¥½ï¼Œç›´æ¥æ¸…ç©º strokesï¼Œç”Ÿæˆå±å¹•åæ ‡ç³»çš„ç²’å­
            
            // å°† World P è½¬æ¢ä¸º Screen P
            // ScreenX = (WorldX - CW/2) * Scale + CW/2
            const screenX = (p.x - canvas.width/2) * canvasScale + canvas.width/2;
            const screenY = (p.y - canvas.height/2) * canvasScale + canvas.height/2;

            if (screenX > 0 && screenX < canvas.width && screenY > 0 && screenY < canvas.height) {
                particles.push(new Particle(screenX, screenY, stroke.color));
            }
        }
    });

    strokes = []; // æ¸…ç©ºç¬”ç”»
    // é‡ç½®ç¼©æ”¾ï¼Œå¦åˆ™æ–°ç”»çš„ä¼šä¹±
    canvasScale = 1;
}

function drawParticles() {
    if (particles.length === 0) return;

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // ç²’å­ä¸å—ç”»æ¿ç¼©æ”¾å½±å“ï¼Œç›´æ¥åœ¨å±å¹•å±‚é£˜è½

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx);
        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }
    ctx.restore();
}

// å¯åŠ¨
createHandLandmarker();

</script>
</body>
</html>